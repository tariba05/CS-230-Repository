# CS-230-Repository

The Gaming Room client wanted to take their existing Android game, Draw It or Lose It, and expand it into a web, multi-platform application. They had some core requirements which included that there could only ever be one instance of the game, that teams or games would not be duplicated, that would have multiple teams and players within it, and to ensure the games were cross-platform compatible. I designed the software including the Singleton pattern to manage the unique game instance and the iterator pattern to traverse the game elements in teams and players. Again, I focused on ensuring there would not be duplicates or other unique aspects in terms of game data handling.

One thing that I did well in developing this documentation was the organization of the system architecture according to object-oriented programming principles such as inheritance, encapsulation, reusability, etc. I also clearly communicated to the developers and nontechnical clients about the areas we used design patterns and technologies for architectural components.

Working through the design document was really useful to me to get ready for coding development. Outlining classes, relationships, and responsibilities before doing the coding clarified the general layout of everything. I was able to have a clearer direction, efficiency, and fewer unknowns to work through. If I were to update one part of the work, I would enhance the System Architecture View with a visual diagram of components and service relationships so that the development team would better understand them.

To understand the user’s needs, I concentrated on reviewing their requests around scalability and cross-platform usage. It was important to their needs that we considered these when making decisions around RESTful API calls to support distributed communication and to support both mobile and desktop clients. Paying attention to user needs in design is essential to creating useable software. Ignoring this will create software that does what is necessary but isn’t usable or adaptable to environments in which it is being used.

In designing software, I typically take client requirements and breakdown the user stories and system requirements, then design the high-level architecture, before considering the detailed class model and component interactions. In the future, I will also use any techniques including domain modeling, UML diagrams, and design patterns in a more deliberate way to create maintainable and scalable software.
